It is well-known that imbalance in trees leads to degradation in performance;
for instance, a $kd$-tree node with every descendant except one in its left
child is effectively useless.  A $kd$-tree full of nodes like this will perform
abysmally for nearest neighbor search, and it is not hard to generate a
pathological dataset that will cause a $kd$-tree of this sort.

This sort of imbalance applies to all types of trees, not just $kd$-trees.  In
our situation, we are interested in a better understanding of this imbalance for
cover trees, and thus endeavor to introduce a more formal measure of imbalance
which is correlated with tree performance.  Numerous measures of tree
imbalance have already been established; one example is that proposed by
\citet{colless1982review}, and another is Sackin's index \citep{sackin1972good},
but we aim to capture a different measure of imbalance that utilizes the leveled
structure of the cover tree.

We already know each node in a cover tree is indexed with an integer level (or
scale).  In the explicit representation of the cover tree, each non-leaf node
has children at a lower level.  But these children need not be strictly one
level lower; see Figure \ref{fig:imbalance}.  In Figure
\ref{fig:imbalance-good}, each cover tree node has children that are strictly
one level lower; we will refer to this as a {\em perfectly balanced cover tree}.
Figure \ref{fig:imbalance-bad}, on the other hand, contains the node
$\mathscr{N}_m$ which has two children with scale two less than $s_m$.  We will
refer to this as an {\em imbalanced cover tree}.  Note that in our definition,
the balance of a cover tree has nothing to do with differing number of
descendants in each child branch but instead only missing levels.

\begin{figure}
\begin{subfigure}[b]{0.585\textwidth}
  \begin{center}
    \input{figures/balanced-cover-tree.tex}
  \end{center}
  \caption{Balanced cover tree.}
  \label{fig:imbalance-good}
\end{subfigure}
\begin{subfigure}[b]{0.415\textwidth}
  \begin{center}
    \input{figures/imbalanced-cover-tree.tex}
  \end{center}
  \caption{Imbalanced cover tree.}
  \label{fig:imbalance-bad}
\end{subfigure}
\caption{Balanced and imbalanced cover trees.}
\label{fig:imbalance}
\end{figure}

An imbalanced cover tree can happen in practice, and in the worst cases, the
imbalance may be far worse than the simple graphs of Figure \ref{fig:imbalance}.
Consider a dataset with a single outlier which is very far away from all of the
other points\footnote{Note also that for an outlier sufficiently far away, the
expansion constant is $N - 1$.}.  Figure \ref{fig:outlier} shows what happens in
this situation: the root node has two children; one of these children has only
the outlier as a descendant, and the other child has the rest of the points in
the dataset as a descendant.  In fact, it is easy to find datasets with a
handful of outliers that give rise to a chain-like structure at the top of the
tree: see Figure \ref{fig:outliers} for an illustration\footnote{As a side note,
this behavior is not limited to cover trees, and can happen to mean-split
$kd$-trees too, especially in higher dimensions.}.

\begin{figure}
\begin{center}
  \input{figures/single-outlier-tree.tex}
\end{center}
\caption{Single-outlier cover tree.}
\label{fig:outlier}
\end{figure}

\begin{figure}
\begin{center}
  \input{figures/multiple-outlier-tree.tex}
\end{center}
\caption{A badly-drawn multiple-outlier cover tree.}
\label{fig:outliers}
\end{figure}

A tree that has this chain-like structure all the way down is going to perform
horrendously; motivated by this observation, we define a measure of tree
imbalance.

\begin{defn}
The {\it cover node imbalance} $i_n(\mathscr{N}_i)$ for a cover tree node
$\mathscr{N}_i$ with scale $s_i$ in the cover tree $\mathscr{T}$ is defined as
the cumulative number of missing levels between the node and its parent
$\mathscr{N}_p$ (which has scale $s_p$).  If
the node is a leaf child (that is, $s_i = -\infty$), then number of missing
levels is defined as the difference between $s_p$ and $s_{\min} - 1$ where
$s_{\min}$ is the smallest scale of a non-leaf node in $\mathscr{T}$.  If
$\mathscr{N}_i$ is the root of the tree, then the cover node imbalance is 0.
Explicitly written, this calculation is

\begin{equation}
i_n(\mathscr{N}_i) = \begin{dcases*}
  s_p - s_i - 1 & if $\mathscr{N}_i$ is not a leaf and not the root node \\
  \max(s_p - s_{\min} - 1, \; 0) & if $\mathscr{N}_i$ is a leaf \\
  0 & if $\mathscr{N}_i$ is the root node.
  \end{dcases*}
\end{equation}
\end{defn}

This simple definition of cover node imbalance is easy to calculate, and using
it, we can generalize to a measure of imbalance for the full tree.

\begin{defn}
\label{def:imbalance}
The {\it cover tree imbalance} $i_t(\mathscr{T})$ for a cover tree $\mathscr{T}$
is defined as the cumulative number of missing levels in the tree.  This can be
expressed as a function of cover node imbalances easily:

\begin{equation}
i_t(\mathscr{T}) = \sum_{\mathscr{N}_i \in \mathscr{T}} i_n(\mathscr{N}_i).
\end{equation}
\end{defn}

A perfectly balanced cover tree $\mathscr{T}_b$ with no missing levels has
imbalance $i_t(\mathscr{T}_b) = 0$ (for instance, Figure
\ref{fig:imbalance-good}).  A worst-case cover tree $\mathscr{T}_w$ which is
entirely a chain-like structure with maximum scale $s_{\max}$ and minimum scale
$s_{\min}$ will have imbalance $i_t(\mathscr{T}_w) \sim N (s_{\max} -
s_{\min})$.  Because of this chain-like structure, each level has only one node
and thus there are at least $N$ levels; or, $s_{\max} - s_{\min} \ge N$, meaning
that in the worst case the imbalance is quadratic in $N$.

However, for most real-world datasets with the cover tree implementation in {\bf
mlpack} \citep{mlpack2013} and the reference implementation
\citep{langford2006}, the tree imbalance is near-linear with the number of
points.  Most of the cover tree imbalance is contributed by leaf nodes whose
parent has scale greater than $s_{\min}$.  At this time, no cover tree
construction algorithm specifically aims to minimize imbalance.

%To demonstrate this, Table \ref{tab:emp_imbalance} shows empirically
%calculated cover tree imbalance for cover trees on a number of datasets built
%with both the cover tree implementation in {\bf mlpack} \citep{mlpack2013} and
%the original reference implementation \citep{langford2006}.

%\begin{table}[tb]
%\begin{center}
%\begin{tabular}{|c|c|c|r|r|}
%\hline
%Dataset & $N$ & $d$ & reference & mlpack \\
%\hline
%wine & & & & \\
%isolet & & & & \\
%corel & & & & \\
%mnist & 70000 & 784 & & \\
%bio & & & & \\
%phy & & & & \\
%covertype & & & & \\
%LCDM & & & & \\
%\hline
%\end{tabular}
%\end{center}
%\caption{Empirical tree imbalance calculations.}
%\label{tab:emp_imbalance}
%\end{table}

%{\bf TODO: Can any bound be proven on $i_t(\mathscr{T})$?  I haven't thought of
%anything successfully yet.}
