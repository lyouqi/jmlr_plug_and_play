It is well-known that imbalance in trees leads to degradation in performance;
for instance, a $kd$-tree node with every descendant except one in its left
child is effectively useless.  A $kd$-tree full of nodes like this will perform
abysmally for nearest neighbor search, and it is not hard to generate a dataset
that will cause a $kd$-tree of this sort.

This sort of imbalance applies to all types of trees, not just $kd$-trees.  In
our situation, we are interested in a better understanding of this imbalance for
cover trees, and thus endeavor to introduce a more formal measure of imbalance
which is correlated with tree performance.  Numerous measures of tree
imbalance have already been established; one example is that proposed by
\citet{colless1982review}, and another is Sackin's index \citep{sackin1972good},
but we aim to capture a different measure of imbalance that utilizes the leveled
structure of the cover tree.

We already know each node in a cover tree is indexed with an integer level (or
scale).  In the explicit representation of the cover tree, each non-leaf node
has children at a lower level.  But these children need not be strictly one
level lower; see Figure \ref{fig:imbalance}.  In Figure
\ref{fig:imbalance-good}, each cover tree node has children that are strictly
one level lower; we will refer to this as a {\em perfectly balanced cover tree}.
Figure \ref{fig:imbalance-bad}, on the other hand, contains the node
$\mathscr{N}_m$ which has two children with scale two less than $s_m$.  We will
refer to this as an {\em imbalanced cover tree}.  Note that in our definition,
the balance of a cover tree has nothing to do with differing number of
descendants in each child branch but instead only missing levels.

\begin{figure}
\begin{subfigure}[b]{0.585\textwidth}
  \begin{center}
    \input{figures/balanced-cover-tree.tex}
  \end{center}
  \caption{Balanced cover tree.}
  \label{fig:imbalance-good}
\end{subfigure}
\begin{subfigure}[b]{0.415\textwidth}
  \begin{center}
    \input{figures/imbalanced-cover-tree.tex}
  \end{center}
  \caption{Imbalanced cover tree.}
  \label{fig:imbalance-bad}
\end{subfigure}
\caption{Balanced and imbalanced cover trees.}
\label{fig:imbalance}
\end{figure}

An imbalanced cover tree can---and often does---happen in practice, and the
imbalance may be far worse than the simple graphs of Figure \ref{fig:imbalance}.
Consider a dataset with a single outlier which is very far away from all of the
other points\footnote{Note also that for an outlier sufficiently far away, the
expansion constant is $N - 1$.}.  Figure \ref{fig:outlier} shows what happens in
this situation: the root node has two children; one of these children has only
the outlier as a descendant, and the other child has the rest of the points in
the dataset as a descendant.  In fact, it is easy to find datasets with multiple
outliers which give rise to a chain-like structure at the top of the tree: see
Figure \ref{fig:outliers} for an illustration\footnote{As a side note, this
behavior is not limited to cover trees, and can happen to mean-split $kd$-trees
too, especially in higher dimensions.}.

\begin{figure}
\begin{center}
  \input{figures/single-outlier-tree.tex}
\end{center}
\caption{Single-outlier cover tree.}
\label{fig:outlier}
\end{figure}

\begin{figure}
\begin{center}
  \input{figures/multiple-outlier-tree.tex}
\end{center}
\caption{A badly-drawn multiple-outlier cover tree.}
\label{fig:outliers}
\end{figure}

A tree that has this chain-like structure all the way down is going to perform
horrendously; motivated by this observation, we define a measure of tree
imbalance.

\begin{defn}
The {\it cover node imbalance} $i(\mathscr{N}_i)$ for a cover tree node
$\mathscr{N}_i$ with scale $s_i$ in the cover tree $\mathscr{T}$ is defined as
the cumulative number of missing levels between the node and its children.  If
the node has a leaf child (which has level $-\infty$), then number of missing
levels is defined as the difference between $s_i$ and $s_{\min} - 1$ where
$s_{\min}$ is the smallest scale of a non-leaf node in $\mathscr{T}$.
Explicitly written, this calculation is

\begin{equation}
i(\mathscr{N}_i) = \left( \sum_{\mathscr{N}_c \in \mathscr{C}(\mathscr{N}_i),
\mathscr{C}(\mathscr{N}_c) \ne \emptyset} s_i - s_c - 1 \right) + \left(
\sum_{\mathscr{N}_c \in \mathscr{C}(\mathscr{N}_i), \mathscr{C}(\mathscr{N}_c) =
\emptyset} \max(s_i - s_{\min} - 1, 0) \right).
\end{equation}
\end{defn}

Given this definition for a single node, then, we can generalize to the full
tree.

\begin{defn}
The {\it cover tree imbalance} $b(\mathscr{T})$ for a cover tree $\mathscr{T}$
is defined as the cumulative number of missing levels in the tree.  This can be
expressed as a function of cover node imbalances easily:

\begin{equation}
b(\mathscr{T}) = \sum_{\mathscr{N}_i \in \mathscr{T}} i(\mathscr{N}_i).
\end{equation}
\end{defn}

A perfectly balanced cover tree $\mathscr{T}_b$ with no missing levels has
imbalance $i(\mathscr{T}_b) = 0$.  A worst-case cover tree $\mathscr{T}_w$ which
is entirely a chain-like structure with maximum scale $s_{\max}$ and minimum
scale $s_{\min}$ will have imbalance $i(\mathscr{T}_w) = N (s_{\max} -
s_{\min})$.  Because of this chain-like structure, each level has only one node
and thus there are at least $N$ levels; or, $s_{\max} - s_{\min} \ge N$, meaning
that the imbalance is actually quadratic in $N$!

As we will see later empirically, the notion of cover tree imbalance does a good
job of capturing the `goodness' of a tree.  We will use this notion in order to
quantify the worst-case performance of dual-tree algorithms using the cover
tree.

{\bf TODO: Can any bound be proven on $i(\mathscr{T})$?  I haven't thought of
anything successfully yet.}
